////  RomoDrive.swift//  DrivingVehicle//import Foundationimport AVFoundationpublic class RomoDrive: VehicleTemplate, RMCoreDelegate{    private var _robot: RMCoreRobotRomo3? = nil    private var _socket: Skyway?    private var _speed: Float! = 0.0    private var _radius: Float! = 0.1    init(socket: Skyway){        super.init()        _socket = socket        RMCore.setDelegate(self)    }    func dispatch_async_main(block: () -> ()) {        dispatch_async(dispatch_get_main_queue(), block)    }    // MARK: RMCoreDelegate    public func robotDidConnect(robot: RMCoreRobot!) {        if (robot.isKindOfClass(RMCoreRobotRomo3)) {            self.dispatch_async_main {                self._robot = robot as? RMCoreRobotRomo3                self._robot?.tiltByAngle(130.0, completion: nil)            }        }    }    public func robotDidDisconnect(robot: RMCoreRobot!) {        if (robot == _robot) {            _robot = nil;        }    }    // MARK: VehicleTemplate    override func driveForward(speed:NSNumber?) {        if(speed != nil){            _speed = speed!.floatValue        }        if (_robot?.respondsToSelector("driveForwardWithSpeed:") == true) {            self.dispatch_async_main {                self._robot?.driveForwardWithSpeed(_speed)            }        }    }    override func driveBackward(speed:NSNumber?){        if(speed != nil){            _speed = speed!.floatValue        }        if (_robot?.respondsToSelector("driveBackwardWithSpeed:") == true) {            self.dispatch_async_main {                self._robot?.driveBackwardWithSpeed(_speed)            }        }    }    override func rotateLeft(radius:NSNumber?){        if(radius != nil){            _radius = calcradius(radius!.floatValue)        }        let rotate: Float = (1.2 - _radius) * 0.2        if (_robot?.respondsToSelector("driveWithRadius:speed:") == true) {            self.dispatch_async_main {                self._robot?.driveWithRadius(0, speed: rotate)            }        }    }    override func rotateRight(radius:NSNumber?){        if(radius != nil){            _radius = calcradius(radius!.floatValue)        }        let rotate: Float = (1.2 - _radius) * 0.2        if (_robot?.respondsToSelector("driveWithRadius:speed:") == true) {            self.dispatch_async_main {                self._robot?.driveWithRadius(0, speed: -1*rotate)            }        }    }    override func driveDiagonallyForwardLeft(speed:NSNumber?,radius:NSNumber?){        if(speed != nil){            _speed = speed!.floatValue        }        if(radius != nil){            _radius = calcradius(radius!.floatValue)        }        if (_robot?.respondsToSelector("driveWithRadius:speed:") == true) {            self.dispatch_async_main {                self._robot?.driveWithRadius(_radius, speed: _speed)            }        }    }    override func driveDiagonallyForwardRight(speed:NSNumber?,radius:NSNumber?){        if(speed != nil){            _speed = speed!.floatValue        }        if(radius != nil){            _radius = calcradius(radius!.floatValue)        }        if (_robot?.respondsToSelector("driveWithRadius:speed:") == true) {            self.dispatch_async_main {                self._robot?.driveWithRadius(-1*_radius, speed: _speed)            }        }    }    override func driveDiagonallyBackwardLeft(speed:NSNumber?,radius:NSNumber?){        if(speed != nil){            _speed = speed!.floatValue        }        if(radius != nil){            _radius = calcradius(radius!.floatValue)        }        if (_robot?.respondsToSelector("driveWithRadius:speed:") == true) {            self.dispatch_async_main {                self._robot?.driveWithRadius(_radius, speed: -1*_speed)            }        }    }    override func driveDiagonallyBackwardRight(speed:NSNumber?,radius:NSNumber?){        if(speed != nil){            _speed = speed!.floatValue        }        if(radius != nil){            _radius = calcradius(radius!.floatValue)        }        if (_robot?.respondsToSelector("driveWithRadius:speed:") == true) {            self.dispatch_async_main {                self._robot?.driveWithRadius(-1*_radius, speed: -1*_speed)            }        }    }    override func stopDriving(){        if (_robot?.respondsToSelector("stopDriving") == true) {            self.dispatch_async_main {                self._robot?.stopDriving()            }        }    }    override func headingUp(){        if (_robot?.respondsToSelector("tiltToAngle:completion:") == true) {            self.dispatch_async_main {                self._robot?.tiltToAngle(130.0, completion: nil)            }        }    }    override func headingDown(){        if (_robot?.respondsToSelector("tiltToAngle:completion:") == true) {            self.dispatch_async_main {                self._robot?.tiltToAngle(70.0, completion: nil)            }        }    }    override func stopHeading() {        if (_robot?.respondsToSelector("stopTilting") == true) {            self.dispatch_async_main {                self._robot?.stopTilting()            }            self.sendanglestate()        }    }        override func headingtoangle(value: NSNumber) {        var value_f:Float = value.floatValue        value_f = value_f * 60.0 + 75.0        if (_robot?.respondsToSelector("tiltToAngle:completion:") == true) {            self.dispatch_async_main {            self._robot?.tiltToAngle(value_f, completion: {success in                self.sendanglestate()            })            }        }    }        private func calcradius(radius:Float) -> Float {        let radius_t = atan((radius * 6) - 0.4) * 2.0 / Float(M_PI)        return 1.15 - radius_t    }        private func sendanglestate(){        if let robot = _robot {            let angle = (robot.headAngle - 75.0) / 60.0            let send_dict: Dictionary = [                "AngleState": Double(angle)            ]            _socket?.send(send_dict)        }            }        override func getvehiclestatus(){        let currentDevice: UIDevice! = UIDevice.currentDevice()        if (currentDevice !== nil) {            if let robot = _robot {                let angle = (robot.headAngle - 75.0) / 60.0                let romo_battery: Float = robot.vitals.batteryLevel                currentDevice.batteryMonitoringEnabled = true                let ios_battery: Float = currentDevice.batteryLevel                let send_dict: Dictionary = [                    "AngleState": Double(angle),                    "VehicleBattery": Double(romo_battery),                    "IOSBattery": Double(ios_battery)                ]                _socket?.send(send_dict)            }        }        }}